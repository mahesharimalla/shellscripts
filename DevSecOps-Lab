
29

pipeline {
    agent any
tools {
        jdk 'jdk_21'
        nodejs 'node_22'
        
    }
    
     environment {
       SONAR_TOKEN     = credentials('lms_sonartoken')
       SCANNER_HOME    = tool 'sonar_scanner'
        LMS_REGISTRY_URL = credentials('LMS_NEXUS_REGISTRY_URL')
        LMS_DOCKER_REPO  = credentials('LMS_NEXUS_DOCKER_REPO')
        LMS_PROJECT_NAME = credentials('LMS_NEXUS_PROJECT')
    }
    
    stages {
        stage('üì• Checkout Code') {
        steps {
            git branch: 'dev',
                credentialsId: 'github-token',
                url: 'https://github.com/mahesharimalla/lms.git'
        }
    }
  
        stage('Compile Applications') {
    parallel {
        stage('Compile Backend') {
            steps {
                dir('api') {
                    sh '''
                      npm install
                      npx prisma generate
                      npm run lint
                      npm run build
                    '''
                }
            }
        }

        stage('Compile Frontend') {
            steps {
                dir('webapp') {
                    sh '''
                      npm install
                      npm run build
                    '''
                }
            }
        }
    }
}


    

     stage('Gate-0: Gitleaks Secret Scan') {
    steps {
        script {
            sh '''
              set +e
              echo "üîç Running Gitleaks Secret Scan..."

              mkdir -p security-reports/gitleaks

              gitleaks detect \
                --source . \
                --no-git \
                --redact \
                --report-format json \
                --report-path security-reports/gitleaks/gitleaks-report.json

              EXIT_CODE=$?

              # Generate HTML only if report exists and is not empty
              if [ -s security-reports/gitleaks/gitleaks-report.json ]; then
                echo "‚ö† Secrets detected. Generating HTML report..."

                cat <<'EOF' > security-reports/gitleaks/gitleaks-report.html
<html>
<head>
  <title>Gitleaks Security Report</title>
  <style>
    body { font-family: Arial; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #d32f2f; color: white; }
  </style>
</head>
<body>
<h2>‚ùå Gitleaks Secret Detection Report</h2>
<table>
<tr>
  <th>Rule</th>
  <th>File</th>
  <th>Line</th>
  <th>Confidence</th>
</tr>
EOF

                jq -r '.[] |
                  "<tr><td>" + .rule +
                  "</td><td>" + .file +
                  "</td><td>" + (.line|tostring) +
                  "</td><td>" + .confidence +
                  "</td></tr>"
                ' security-reports/gitleaks/gitleaks-report.json >> security-reports/gitleaks/gitleaks-report.html

                echo "</table></body></html>" >> security-reports/gitleaks/gitleaks-report.html
              fi

              exit $EXIT_CODE
            '''
        }
    }
    post {
        always {
            archiveArtifacts artifacts: 'security-reports/gitleaks/*', fingerprint: true
        }
        failure {
            echo '‚ùå Gate-0 FAILED ‚Äì Secrets detected. Review Gitleaks report.'
        }
        success {
            echo '‚úÖ Gate-0 PASSED ‚Äì No secrets detected.'
        }
    }
}


/*
stage('Gate-0: TruffleHog Secret Scan') {
    steps {
        script {
            sh '''
              set -e
              echo "üîç Running TruffleHog Secret Scan (Full Git History)..."

              mkdir -p security-reports/trufflehog

              trufflehog git file://$PWD \
                --json \
                --no-update \
                > security-reports/trufflehog/trufflehog-report.json

              # Count findings
              FINDINGS=$(jq length security-reports/trufflehog/trufflehog-report.json)

              if [ "$FINDINGS" -gt 0 ]; then
                echo "‚ùå TruffleHog detected $FINDINGS potential secrets"
                exit 1
              else
                echo "‚úÖ No secrets detected by TruffleHog"
              fi
            '''
        }
    }
    post {
        always {
            archiveArtifacts artifacts: 'security-reports/trufflehog/*', fingerprint: true
        }
        failure {
            echo '‚ùå Gate-1 FAILED ‚Äì Secrets detected in GitHub repository'
        }
        success {
            echo '‚úÖ Gate-1 PASSED ‚Äì Repository is secret-free'
        }
    }
}

*/




stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar_server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner \\
                           -Dsonar.projectName=lms \\
                           -Dsonar.sources=. \\
                           -Dsonar.projectKey=lms '''
                }
            }
        }



stage('Gate-1: SAST (SonarQube)') {
    steps {
        script {
            try {
                timeout(time: 2, unit: 'MINUTES') {
                    def qg = waitForQualityGate()

                    echo "Gate-1 Status: ${qg.status}"

                    // ‚úÖ If Quality Gate passed ‚Üí continue
                    if (qg.status == 'OK') {
                        echo "Quality Gate passed. No approval required."
                    }
                    // ‚ùå If failed / warn / pending ‚Üí approval required
                    else {
                        def approval = input(
                            message: """
Gate-1 (SAST) did NOT pass ‚ùå

SonarQube Status: ${qg.status}

Component AO approval is required to continue.
""",
                            ok: 'Approve & Continue',
                            parameters: [
                                string(
                                    name: 'JUSTIFICATION',
                                    defaultValue: '',
                                    description: 'Why is this risk acceptable? (Ticket / Reason)'
                                )
                            ]
                        )

                        echo "Gate-1 approved by Component AO. Justification: ${approval}"
                    }
                }
            }
            // ‚è≥ Handles SonarQube stuck / timeout case
            catch (err) {
                def approval = input(
                    message: """
Gate-1 (SAST) TIMEOUT ‚è≥

SonarQube did not return a Quality Gate result in time.

Component AO approval is required to continue.
""",
                    ok: 'Approve & Continue',
                    parameters: [
                        string(
                            name: 'JUSTIFICATION',
                            defaultValue: '',
                            description: 'Why is this risk acceptable? (Ticket / Reason)'
                        )
                    ]
                )

                echo "Gate-1 approved after timeout. Justification: ${approval}"
            }
        }
    }
}


stage('üõ°Ô∏è Gate-2: OWASP Dependency Check') {
    steps {
        echo "üîç Running OWASP Dependency-Check with Quality Gates..."

        dependencyCheck(
            odcInstallation: 'DP_Check',
            additionalArguments: """
                --project LMS-Application
                --scan .
                --format XML
                --failOnCVSS 7
            """
        )

        dependencyCheckPublisher(
            pattern: '**/dependency-check-report.xml'
        )
    }

    post {
        success {
            echo "‚úÖ Dependency-Check PASSED (No HIGH / CRITICAL vulnerabilities)"
        }

        failure {
            echo "‚ùå Dependency-Check FAILED (HIGH / CRITICAL vulnerabilities found)"

            emailext(
                subject: "üö® OWASP Dependency Check FAILED | Pipeline Stopped",
                body: """
OWASP Dependency-Check FAILED.

‚ùå HIGH / CRITICAL vulnerabilities detected
‚ùå Pipeline STOPPED

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
""",
                to: 'security-ao@company.com'
            )
        }
    }
}

stage('üßë‚Äç‚öñÔ∏è Gate-2 Approval: Component AO') {
    when {
        expression { currentBuild.currentResult == 'SUCCESS' }
    }

    steps {
        script {
            timeout(time: 24, unit: 'HOURS') {
                def decision = input(
                    message: 'Approve OWASP Dependency-Check results?',
                    ok: 'Submit Decision',
                    submitter: 'component-ao',
                    parameters: [
                        choice(
                            name: 'DECISION',
                            choices: ['APPROVE', 'ABORT'],
                            description: 'APPROVE to continue, ABORT to stop the pipeline'
                        )
                    ]
                )

                if (decision == 'ABORT') {
                    error('‚ùå OWASP Dependency Check rejected by Component AO')
                }

                echo '‚úÖ OWASP Dependency Check approved by Component AO'
            }
        }
    }

    post {
        success {
            emailext(
                subject: "‚úÖ OWASP Dependency Check APPROVED | Component AO",
                body: """
OWASP Dependency-Check PASSED.

‚úî No HIGH / CRITICAL vulnerabilities
‚úî Approved by Component AO

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
""",
                to: 'security-ao@company.com'
            )
        }
    }
}


stage('Build & Push Docker Images') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login $LMS_REGISTRY_URL \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image"
          docker build --no-cache -t ${apiImage} ./api

          echo "üì§ Pushing API image"
          docker push ${apiImage}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image"
          docker build --no-cache -t ${webappImage} ./webapp

          echo "üì§ Pushing WebApp image"
          docker push ${webappImage}
        """
      }
    }
  }
}


   stage('Trivy Docker Image Scan') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      sh """
        echo "üîé Scanning API image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${apiImage} | tee trivy-api-scan.txt

        echo "üîé Scanning WebApp image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${webappImage} | tee trivy-webapp-scan.txt
      """
    }
  }
}



stage('üöÄ Deploy LMS via Docker Run (Secure)') {
  steps {
    script {
      withCredentials([
        usernamePassword(
          credentialsId: 'nexus_cred',
          usernameVariable: 'NEXUS_USERNAME',
          passwordVariable: 'NEXUS_PASSWORD'
        ),
        //string(credentialsId: 'LMS_POSTGRES_USER', variable: 'LMS_POSTGRES_USER'),
        //string(credentialsId: 'LMS_POSTGRES_PASSWORD', variable: 'LMS_POSTGRES_PASSWORD'),
        //string(credentialsId: 'LMS_POSTGRES_DB', variable: 'LMS_POSTGRES_DB'),
        //string(credentialsId: 'DATABASE_URL', variable: 'DATABASE_URL')
      ]) {

        sh(
          shell: '/bin/bash',
          script: '''
            set -e
            set +x

            echo "üîê Logging in to Nexus"
            echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
              -u "$NEXUS_USERNAME" --password-stdin

            echo "üåê Creating Docker network"
            docker network create lms-net || true

            echo "üßπ Cleaning old containers"
            docker rm -f lms-webapp lms-api lms-postgres 2>/dev/null || true

            echo "üêò Starting PostgreSQL"
            docker run -d \
              --name lms-postgres \
              --network lms-net \
              --restart unless-stopped \
              -e POSTGRES_USER="postgres" \
              -e POSTGRES_PASSWORD="postgres123" \
              -e POSTGRES_DB="mydb" \
              -v lms-db-data:/var/lib/postgresql/data \
              postgres:15

            echo "üöÄ Starting LMS API"
            docker run -d \
              --name lms-api \
              --network lms-net \
              --restart unless-stopped \
              -p 8081:8081 \
              -e MODE=production \
              -e PORT=8081 \
              -e DATABASE_URL="postgresql://postgres:postgres123@lms-postgres:5432/mydb" \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-api:$BUILD_NUMBER"


            echo "üåê Starting LMS WebApp"
            docker run -d \
              --name lms-webapp \
              --network lms-net \
              --restart unless-stopped \
              -p 3001:80 \
              -e VITE_API_URL=http://192.162.11.18:8081/api \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-webapp:$BUILD_NUMBER"
          '''
        )
      }
    }
  }
}

/*
stage('DAST - OWASP ZAP') {
    steps {
        sh '''
          set -e
          mkdir -p zap-report
          /opt/zaproxy/zap.sh -cmd \
            -port 8090 \
            -quickurl http://192.168.11.18:3001 \
            -quickout zap-report/zap-report.html \
            -quickprogress
        '''
    }
    post {
        always {
            publishHTML(target: [
                reportDir: 'zap-report',
                reportFiles: 'zap-report.html',
                reportName: 'OWASP ZAP DAST Report',
                keepAll: true,
                alwaysLinkToLastBuild: true,
                allowMissing: true
            ])
        }
    }
}
*/


stage('Gate-4: DAST - OWASP ZAP (Docker)') {
    steps {
        sh '''#!/bin/bash
          set -euo pipefail

          echo "üîç Starting OWASP ZAP Baseline DAST scan..."
          echo "üìÅ Preparing report directory"

          mkdir -p zap-report
          chmod 775 zap-report

          echo "üê≥ Running ZAP container..."

          docker run --rm \
            --user root \
            --network lms-net \
            -v "$PWD/zap-report:/zap/wrk" \
            zap-dast:latest \
            zap-baseline.py \
              -t http://lms-api:3001 \
              -r zap-report.html \
              -I

          echo "‚úÖ ZAP scan completed"
        '''
    }
    post {
        always {
            echo "üìä Publishing OWASP ZAP report..."
            publishHTML(target: [
                reportDir: 'zap-report',
                reportFiles: 'zap-report.html',
                reportName: 'OWASP ZAP DAST Report',
                keepAll: true,
                alwaysLinkToLastBuild: true,
                allowMissing: false
            ])
        }
        failure {
            echo '‚ùå Gate-4 FAILED ‚Äì OWASP ZAP detected security issues'
        }
        success {
            echo '‚úÖ Gate-4 PASSED ‚Äì No blocking vulnerabilities detected'
        }
    }
}






    }
}




========================================================================================
28
pipeline {
    agent any
tools {
        jdk 'jdk_21'
        nodejs 'node_22'
        
    }
    
     environment {
       SONAR_TOKEN     = credentials('lms_sonartoken')
       SCANNER_HOME    = tool 'sonar_scanner'
        LMS_REGISTRY_URL = credentials('LMS_NEXUS_REGISTRY_URL')
        LMS_DOCKER_REPO  = credentials('LMS_NEXUS_DOCKER_REPO')
        LMS_PROJECT_NAME = credentials('LMS_NEXUS_PROJECT')
    }
    
    stages {
        stage('üì• Checkout Code') {
        steps {
            git branch: 'dev',
                credentialsId: 'github-token',
                url: 'https://github.com/mahesharimalla/lms.git'
        }
    }
  
        stage('Compile Applications') {
    parallel {
        stage('Compile Backend') {
            steps {
                dir('api') {
                    sh '''
                      npm install
                      npx prisma generate
                      npm run lint
                      npm run build
                    '''
                }
            }
        }

        stage('Compile Frontend') {
            steps {
                dir('webapp') {
                    sh '''
                      npm install
                      npm run build
                    '''
                }
            }
        }
    }
}


    
/*
     stage('Gate-0: Gitleaks Secret Scan') {
    steps {
        script {
            sh '''
              set +e
              echo "üîç Running Gitleaks Secret Scan..."

              mkdir -p security-reports/gitleaks

              gitleaks detect \
                --source . \
                --no-git \
                --redact \
                --report-format json \
                --report-path security-reports/gitleaks/gitleaks-report.json

              EXIT_CODE=$?

              # Generate HTML only if report exists and is not empty
              if [ -s security-reports/gitleaks/gitleaks-report.json ]; then
                echo "‚ö† Secrets detected. Generating HTML report..."

                cat <<'EOF' > security-reports/gitleaks/gitleaks-report.html
<html>
<head>
  <title>Gitleaks Security Report</title>
  <style>
    body { font-family: Arial; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #d32f2f; color: white; }
  </style>
</head>
<body>
<h2>‚ùå Gitleaks Secret Detection Report</h2>
<table>
<tr>
  <th>Rule</th>
  <th>File</th>
  <th>Line</th>
  <th>Confidence</th>
</tr>
EOF

                jq -r '.[] |
                  "<tr><td>" + .rule +
                  "</td><td>" + .file +
                  "</td><td>" + (.line|tostring) +
                  "</td><td>" + .confidence +
                  "</td></tr>"
                ' security-reports/gitleaks/gitleaks-report.json >> security-reports/gitleaks/gitleaks-report.html

                echo "</table></body></html>" >> security-reports/gitleaks/gitleaks-report.html
              fi

              exit $EXIT_CODE
            '''
        }
    }
    post {
        always {
            archiveArtifacts artifacts: 'security-reports/gitleaks/*', fingerprint: true
        }
        failure {
            echo '‚ùå Gate-0 FAILED ‚Äì Secrets detected. Review Gitleaks report.'
        }
        success {
            echo '‚úÖ Gate-0 PASSED ‚Äì No secrets detected.'
        }
    }
}


*/

stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar_server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner \\
                           -Dsonar.projectName=lms \\
                           -Dsonar.sources=. \\
                           -Dsonar.projectKey=lms '''
                }
            }
        }



stage('Gate-1: SAST (SonarQube)') {
    steps {
        script {
            try {
                timeout(time: 2, unit: 'MINUTES') {
                    def qg = waitForQualityGate()

                    echo "Gate-1 Status: ${qg.status}"

                    // ‚úÖ If Quality Gate passed ‚Üí continue
                    if (qg.status == 'OK') {
                        echo "Quality Gate passed. No approval required."
                    }
                    // ‚ùå If failed / warn / pending ‚Üí approval required
                    else {
                        def approval = input(
                            message: """
Gate-1 (SAST) did NOT pass ‚ùå

SonarQube Status: ${qg.status}

Component AO approval is required to continue.
""",
                            ok: 'Approve & Continue',
                            parameters: [
                                string(
                                    name: 'JUSTIFICATION',
                                    defaultValue: '',
                                    description: 'Why is this risk acceptable? (Ticket / Reason)'
                                )
                            ]
                        )

                        echo "Gate-1 approved by Component AO. Justification: ${approval}"
                    }
                }
            }
            // ‚è≥ Handles SonarQube stuck / timeout case
            catch (err) {
                def approval = input(
                    message: """
Gate-1 (SAST) TIMEOUT ‚è≥

SonarQube did not return a Quality Gate result in time.

Component AO approval is required to continue.
""",
                    ok: 'Approve & Continue',
                    parameters: [
                        string(
                            name: 'JUSTIFICATION',
                            defaultValue: '',
                            description: 'Why is this risk acceptable? (Ticket / Reason)'
                        )
                    ]
                )

                echo "Gate-1 approved after timeout. Justification: ${approval}"
            }
        }
    }
}


stage('üõ°Ô∏è Gate-2: OWASP Dependency Check') {
    steps {
        echo "üîç Running OWASP Dependency-Check with Quality Gates..."

        dependencyCheck(
            odcInstallation: 'DP_Check',
            additionalArguments: """
                --project LMS-Application
                --scan .
                --format XML
                --failOnCVSS 7
            """
        )

        dependencyCheckPublisher(
            pattern: '**/dependency-check-report.xml'
        )
    }

    post {
        success {
            echo "‚úÖ Dependency-Check PASSED (No HIGH / CRITICAL vulnerabilities)"
        }

        failure {
            echo "‚ùå Dependency-Check FAILED (HIGH / CRITICAL vulnerabilities found)"

            emailext(
                subject: "üö® OWASP Dependency Check FAILED | Pipeline Stopped",
                body: """
OWASP Dependency-Check FAILED.

‚ùå HIGH / CRITICAL vulnerabilities detected
‚ùå Pipeline STOPPED

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
""",
                to: 'security-ao@company.com'
            )
        }
    }
}

stage('üßë‚Äç‚öñÔ∏è Gate-2 Approval: Component AO') {
    when {
        expression { currentBuild.currentResult == 'SUCCESS' }
    }

    steps {
        script {
            timeout(time: 24, unit: 'HOURS') {
                def decision = input(
                    message: 'Approve OWASP Dependency-Check results?',
                    ok: 'Submit Decision',
                    submitter: 'component-ao',
                    parameters: [
                        choice(
                            name: 'DECISION',
                            choices: ['APPROVE', 'ABORT'],
                            description: 'APPROVE to continue, ABORT to stop the pipeline'
                        )
                    ]
                )

                if (decision == 'ABORT') {
                    error('‚ùå OWASP Dependency Check rejected by Component AO')
                }

                echo '‚úÖ OWASP Dependency Check approved by Component AO'
            }
        }
    }

    post {
        success {
            emailext(
                subject: "‚úÖ OWASP Dependency Check APPROVED | Component AO",
                body: """
OWASP Dependency-Check PASSED.

‚úî No HIGH / CRITICAL vulnerabilities
‚úî Approved by Component AO

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
""",
                to: 'security-ao@company.com'
            )
        }
    }
}


stage('Build & Push Docker Images') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login $LMS_REGISTRY_URL \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image"
          docker build --no-cache -t ${apiImage} ./api

          echo "üì§ Pushing API image"
          docker push ${apiImage}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image"
          docker build --no-cache -t ${webappImage} ./webapp

          echo "üì§ Pushing WebApp image"
          docker push ${webappImage}
        """
      }
    }
  }
}


   stage('Trivy Docker Image Scan') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      sh """
        echo "üîé Scanning API image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${apiImage} | tee trivy-api-scan.txt

        echo "üîé Scanning WebApp image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${webappImage} | tee trivy-webapp-scan.txt
      """
    }
  }
}



stage('üöÄ Deploy LMS via Docker Run (Secure)') {
  steps {
    script {
      withCredentials([
        usernamePassword(
          credentialsId: 'nexus_cred',
          usernameVariable: 'NEXUS_USERNAME',
          passwordVariable: 'NEXUS_PASSWORD'
        ),
        //string(credentialsId: 'LMS_POSTGRES_USER', variable: 'LMS_POSTGRES_USER'),
        //string(credentialsId: 'LMS_POSTGRES_PASSWORD', variable: 'LMS_POSTGRES_PASSWORD'),
        //string(credentialsId: 'LMS_POSTGRES_DB', variable: 'LMS_POSTGRES_DB'),
        //string(credentialsId: 'DATABASE_URL', variable: 'DATABASE_URL')
      ]) {

        sh(
          shell: '/bin/bash',
          script: '''
            set -e
            set +x

            echo "üîê Logging in to Nexus"
            echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
              -u "$NEXUS_USERNAME" --password-stdin

            echo "üåê Creating Docker network"
            docker network create lms-net || true

            echo "üßπ Cleaning old containers"
            docker rm -f lms-webapp lms-api lms-postgres 2>/dev/null || true

            echo "üêò Starting PostgreSQL"
            docker run -d \
              --name lms-postgres \
              --network lms-net \
              --restart unless-stopped \
              -e POSTGRES_USER="postgres" \
              -e POSTGRES_PASSWORD="postgres123" \
              -e POSTGRES_DB="mydb" \
              -v lms-db-data:/var/lib/postgresql/data \
              postgres:15

            echo "üöÄ Starting LMS API"
            docker run -d \
              --name lms-api \
              --network lms-net \
              --restart unless-stopped \
              -p 8081:8081 \
              -e MODE=production \
              -e PORT=8081 \
              -e DATABASE_URL="postgresql://postgres:postgres123@lms-postgres:5432/mydb" \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-api:$BUILD_NUMBER"


            echo "üåê Starting LMS WebApp"
            docker run -d \
              --name lms-webapp \
              --network lms-net \
              --restart unless-stopped \
              -p 3001:80 \
              -e VITE_API_URL=http://192.162.11.18:8081/api \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-webapp:$BUILD_NUMBER"
          '''
        )
      }
    }
  }
}


    }
}



=======================================================================================================================================================

pipeline {
    agent any
tools {
        jdk 'jdk_21'
        nodejs 'node_22'
        
    }
    
     environment {
       SONAR_TOKEN     = credentials('lms_sonartoken')
       SCANNER_HOME    = tool 'sonar_scanner'
        LMS_REGISTRY_URL = credentials('LMS_NEXUS_REGISTRY_URL')
        LMS_DOCKER_REPO  = credentials('LMS_NEXUS_DOCKER_REPO')
        LMS_PROJECT_NAME = credentials('LMS_NEXUS_PROJECT')
    }
    
    stages {
        stage('üì• Checkout Code') {
        steps {
            git branch: 'dev',
                credentialsId: 'github-token',
                url: 'https://github.com/mahesharimalla/lms.git'
        }
    }
  
        stage('Compile Applications') {
    parallel {
        stage('Compile Backend') {
            steps {
                dir('api') {
                    sh '''
                      npm install
                      npx prisma generate
                      npm run lint
                      npm run build
                    '''
                }
            }
        }

        stage('Compile Frontend') {
            steps {
                dir('webapp') {
                    sh '''
                      npm install
                      npm run build
                    '''
                }
            }
        }
    }
}


    
/*
     stage('üö¶ Gate-0: Pre-Merge Hygiene') {
    steps {
        script {
            echo "Running Gate-0 checks (Secrets, Lint, Tests)..."

            try {
                // 1Ô∏è‚É£ Secrets Scan (HARD FAIL)
                sh '''
                  gitleaks detect \
                  --source . \
                  --no-git \
                  --redact \
                  --exit-code 1
                '''

                echo "‚úÖ Gitleaks passed ‚Äì No secrets found"

            } catch (err) {
                echo "‚ùå Gitleaks FAILED ‚Äì Secrets detected"

                // Mark build as failed
                currentBuild.result = 'FAILURE'

                // üì£ Notify Developer
                emailext(
                    subject: "üö® Jenkins Gate-0 FAILED: Secrets Detected",
                    body: """
Hello Developer,

üö´ Gate-0 failed due to secrets detected by Gitleaks.

Job      : ${env.JOB_NAME}
Build    : #${env.BUILD_NUMBER}
Branch   : dev
Stage    : Gate-0 (Pre-Merge Hygiene)

üëâ Action Required:
- Remove hardcoded secrets
- Use environment variables / Jenkins credentials
- Re-run pipeline after fixing

Build URL:
${env.BUILD_URL}

-- DevSecOps CI
""",
                    to: 'dev-team@company.com'
                )

                // Stop pipeline immediately
                error("Stopping pipeline ‚Äì Secrets must be fixed by developer")
            }

            // Continue only if gitleaks passed
            sh 'npm install'
            sh 'npm run lint'
            sh 'npm test -- --ci'
        }
    }
}

*/

stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar_server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner \\
                           -Dsonar.projectName=lms \\
                           -Dsonar.sources=. \\
                           -Dsonar.projectKey=lms '''
                }
            }
        }


/*
stage('Gate-1: SAST (SonarQube)') {
    steps {
        script {
            try {
                timeout(time: 10, unit: 'MINUTES') {
                    def qg = waitForQualityGate()

                    echo "Gate-1 Status: ${qg.status}"

                    // ‚úÖ If Quality Gate passed ‚Üí continue
                    if (qg.status == 'OK') {
                        echo "Quality Gate passed. No approval required."
                    }
                    // ‚ùå If failed / warn / pending ‚Üí approval required
                    else {
                        def approval = input(
                            message: """
Gate-1 (SAST) did NOT pass ‚ùå

SonarQube Status: ${qg.status}

Component AO approval is required to continue.
""",
                            ok: 'Approve & Continue',
                            parameters: [
                                string(
                                    name: 'JUSTIFICATION',
                                    defaultValue: '',
                                    description: 'Why is this risk acceptable? (Ticket / Reason)'
                                )
                            ]
                        )

                        echo "Gate-1 approved by Component AO. Justification: ${approval}"
                    }
                }
            }
            // ‚è≥ Handles SonarQube stuck / timeout case
            catch (err) {
                def approval = input(
                    message: """
Gate-1 (SAST) TIMEOUT ‚è≥

SonarQube did not return a Quality Gate result in time.

Component AO approval is required to continue.
""",
                    ok: 'Approve & Continue',
                    parameters: [
                        string(
                            name: 'JUSTIFICATION',
                            defaultValue: '',
                            description: 'Why is this risk acceptable? (Ticket / Reason)'
                        )
                    ]
                )

                echo "Gate-1 approved after timeout. Justification: ${approval}"
            }
        }
    }
}

*/

stage('üõ°Ô∏è OWASP Dependency Check') {

    steps {
        echo "Running OWASP Dependency-Check with Quality Gates..."

        dependencyCheck(
            odcInstallation: 'DP_Check',
            additionalArguments: '''
                --project LMS-Application
                --scan .
                --format XML
                --failOnCVSS 7
            '''
        )

        // Publish results to Jenkins UI (graphs, CVEs, licenses)
        dependencyCheckPublisher(
            pattern: '**/dependency-check-report.xml'
        )
    }
/*
    post {
        success {
            echo "‚úÖ Dependency-Check PASSED (No HIGH / CRITICAL vulnerabilities)"

            // Component AO approval
            timeout(time: 24, unit: 'HOURS') {
                input message: 'Approve OWASP Dependency Check results?',
                      ok: 'Approve',
                      submitter: 'component-ao'
            }

            // Inform Security AO
            emailext(
                subject: "‚úÖ OWASP Dependency Check PASSED | Component AO Approved",
                body: """
OWASP Dependency-Check PASSED.

‚úî No HIGH / CRITICAL vulnerabilities
‚úî Approved by Component AO
‚úî Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}

See Jenkins ‚Üí Dependency-Check for full report.
""",
                to: 'security-ao@company.com'
            )
        }

        failure {
            echo "‚ùå Dependency-Check FAILED (HIGH / CRITICAL vulnerabilities found)"

            emailext(
                subject: "üö® OWASP Dependency Check FAILED | Pipeline Stopped",
                body: """
OWASP Dependency-Check FAILED.

‚ùå HIGH / CRITICAL vulnerabilities detected
‚ùå Pipeline STOPPED
‚úî Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}

Review Jenkins ‚Üí Dependency-Check for:
- CVE list
- Affected dependencies
- CVSS scores
- License issues
""",
                to: 'security-ao@company.com'
            )
        }
    } */
}




stage('Build & Push Docker Images') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login $LMS_REGISTRY_URL \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image"
          docker build --no-cache -t ${apiImage} ./api

          echo "üì§ Pushing API image"
          docker push ${apiImage}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image"
          docker build --no-cache -t ${webappImage} ./webapp

          echo "üì§ Pushing WebApp image"
          docker push ${webappImage}
        """
      }
    }
  }
}


   stage('Trivy Docker Image Scan') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      sh """
        echo "üîé Scanning API image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${apiImage} | tee trivy-api-scan.txt

        echo "üîé Scanning WebApp image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${webappImage} | tee trivy-webapp-scan.txt
      """
    }
  }
}


/*
stage('Build & Push Docker Images') {
  steps {
    script {

      // Short local image names (ONLY these remain on Jenkins)
      def apiLocal    = "lms-api:${env.BUILD_NUMBER}"
      def webLocal    = "lms-webapp:${env.BUILD_NUMBER}"

      // Nexus image names (temporary on Jenkins)
      def apiRemote   = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webRemote   = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image (short name only)"
          docker build --no-cache -t ${apiLocal} ./api

          echo "üè∑Ô∏è Tagging API image for Nexus"
          docker tag ${apiLocal} ${apiRemote}
          

          echo "üì§ Pushing API image to Nexus"
          docker push ${apiLocal} ${apiRemote}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image (short name only)"
          docker build --no-cache -t ${webLocal} ./webapp

          echo "üè∑Ô∏è Tagging WebApp image for Nexus"
          docker tag ${webLocal} ${apiRemote}

          echo "üì§ Pushing WebApp image to Nexus"
          docker push ${webLocal} ${webRemote}

         
        """
      }
    }
  }
}
*/

/*
stage('üöÄ Deploy LMS via Docker Compose') {
  steps {
    script {
      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        //passwordVariable: 'NEXUS_PASSWORD'
      )]) {

dir('/opt/jenkins/lms') {
        sh '''
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh '''
          export BUILD_NUMBER=${BUILD_NUMBER}
          docker compose down
          docker compose pull
          docker compose up -d
        '''
      }
    }
}

  }
}  

*/



stage('üöÄ Deploy LMS via Docker Run') {
  steps {
    script {
      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin

          docker network create lms-net || true

          docker rm -f lms-webapp lms-api lms-postgres || true

          docker run -d \
            --name lms-postgres \
            --network lms-net \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=postgres@123 \
            -e POSTGRES_DB=mydb \
            -v lms-db-data:/var/lib/postgresql/data \
            postgres:15

          docker run -d \
            --name lms-api \
            --network lms-net \
            -p 8081:8081 \
            -e MODE=prod \
            -e PORT=8080 \
            -e DATABASE_URL=postgresql://postgres:strongpassword@lms-postgres:5432/mydb \
            ${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}

          docker run -d \
            --name lms-webapp \
            --network lms-net \
            -p 3000:80 \
            -e MODE=prod \
            -e API_URL=http://lms-api:8081 \
            ${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}
        '''
      }
    }
  }
}


    }
}   


this is my existing pipeline getting these below 

+ echo ****

+ docker login **** -u admin --password-stdin

Login Succeeded

export BUILD_NUMBER=${BUILD_NUMBER} docker compose down docker compose pull docker compose up -d
0.26s

+ export BUILD_NUMBER=52

+ docker compose down

no configuration file provided: not found

script returned exit code 1
