pipeline {
    agent any
tools {
        jdk 'jdk_21'
        nodejs 'node_22'
        
    }
    
     environment {
       SONAR_TOKEN     = credentials('lms_sonartoken')
       SCANNER_HOME    = tool 'sonar_scanner'
        LMS_REGISTRY_URL = credentials('LMS_NEXUS_REGISTRY_URL')
        LMS_DOCKER_REPO  = credentials('LMS_NEXUS_DOCKER_REPO')
        LMS_PROJECT_NAME = credentials('LMS_NEXUS_PROJECT')
    }
    
    stages {
        stage('üì• Checkout Code') {
        steps {
            git branch: 'dev',
                credentialsId: 'github-token',
                url: 'https://github.com/mahesharimalla/lms.git'
        }
    }
  
        stage('Compile Applications') {
    parallel {
        stage('Compile Backend') {
            steps {
                dir('api') {
                    sh '''
                      npm install
                      npx prisma generate
                      npm run lint
                      npm run build
                    '''
                }
            }
        }

        stage('Compile Frontend') {
            steps {
                dir('webapp') {
                    sh '''
                      npm install
                      npm run build
                    '''
                }
            }
        }
    }
}


    
/*
     stage('üö¶ Gate-0: Pre-Merge Hygiene') {
    steps {
        script {
            echo "Running Gate-0 checks (Secrets, Lint, Tests)..."

            try {
                // 1Ô∏è‚É£ Secrets Scan (HARD FAIL)
                sh '''
                  gitleaks detect \
                  --source . \
                  --no-git \
                  --redact \
                  --exit-code 1
                '''

                echo "‚úÖ Gitleaks passed ‚Äì No secrets found"

            } catch (err) {
                echo "‚ùå Gitleaks FAILED ‚Äì Secrets detected"

                // Mark build as failed
                currentBuild.result = 'FAILURE'

                // üì£ Notify Developer
                emailext(
                    subject: "üö® Jenkins Gate-0 FAILED: Secrets Detected",
                    body: """
Hello Developer,

üö´ Gate-0 failed due to secrets detected by Gitleaks.

Job      : ${env.JOB_NAME}
Build    : #${env.BUILD_NUMBER}
Branch   : dev
Stage    : Gate-0 (Pre-Merge Hygiene)

üëâ Action Required:
- Remove hardcoded secrets
- Use environment variables / Jenkins credentials
- Re-run pipeline after fixing

Build URL:
${env.BUILD_URL}

-- DevSecOps CI
""",
                    to: 'dev-team@company.com'
                )

                // Stop pipeline immediately
                error("Stopping pipeline ‚Äì Secrets must be fixed by developer")
            }

            // Continue only if gitleaks passed
            sh 'npm install'
            sh 'npm run lint'
            sh 'npm test -- --ci'
        }
    }
}

*/

stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar_server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner \\
                           -Dsonar.projectName=lms \\
                           -Dsonar.sources=. \\
                           -Dsonar.projectKey=lms '''
                }
            }
        }


/*
stage('Gate-1: SAST (SonarQube)') {
    steps {
        script {
            try {
                timeout(time: 10, unit: 'MINUTES') {
                    def qg = waitForQualityGate()

                    echo "Gate-1 Status: ${qg.status}"

                    // ‚úÖ If Quality Gate passed ‚Üí continue
                    if (qg.status == 'OK') {
                        echo "Quality Gate passed. No approval required."
                    }
                    // ‚ùå If failed / warn / pending ‚Üí approval required
                    else {
                        def approval = input(
                            message: """
Gate-1 (SAST) did NOT pass ‚ùå

SonarQube Status: ${qg.status}

Component AO approval is required to continue.
""",
                            ok: 'Approve & Continue',
                            parameters: [
                                string(
                                    name: 'JUSTIFICATION',
                                    defaultValue: '',
                                    description: 'Why is this risk acceptable? (Ticket / Reason)'
                                )
                            ]
                        )

                        echo "Gate-1 approved by Component AO. Justification: ${approval}"
                    }
                }
            }
            // ‚è≥ Handles SonarQube stuck / timeout case
            catch (err) {
                def approval = input(
                    message: """
Gate-1 (SAST) TIMEOUT ‚è≥

SonarQube did not return a Quality Gate result in time.

Component AO approval is required to continue.
""",
                    ok: 'Approve & Continue',
                    parameters: [
                        string(
                            name: 'JUSTIFICATION',
                            defaultValue: '',
                            description: 'Why is this risk acceptable? (Ticket / Reason)'
                        )
                    ]
                )

                echo "Gate-1 approved after timeout. Justification: ${approval}"
            }
        }
    }
}

*/

stage('üõ°Ô∏è OWASP Dependency Check') {

    steps {
        echo "Running OWASP Dependency-Check with Quality Gates..."

        dependencyCheck(
            odcInstallation: 'DP_Check',
            additionalArguments: '''
                --project LMS-Application
                --scan .
                --format XML
                --failOnCVSS 7
            '''
        )

        // Publish results to Jenkins UI (graphs, CVEs, licenses)
        dependencyCheckPublisher(
            pattern: '**/dependency-check-report.xml'
        )
    }
/*
    post {
        success {
            echo "‚úÖ Dependency-Check PASSED (No HIGH / CRITICAL vulnerabilities)"

            // Component AO approval
            timeout(time: 24, unit: 'HOURS') {
                input message: 'Approve OWASP Dependency Check results?',
                      ok: 'Approve',
                      submitter: 'component-ao'
            }

            // Inform Security AO
            emailext(
                subject: "‚úÖ OWASP Dependency Check PASSED | Component AO Approved",
                body: """
OWASP Dependency-Check PASSED.

‚úî No HIGH / CRITICAL vulnerabilities
‚úî Approved by Component AO
‚úî Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}

See Jenkins ‚Üí Dependency-Check for full report.
""",
                to: 'security-ao@company.com'
            )
        }

        failure {
            echo "‚ùå Dependency-Check FAILED (HIGH / CRITICAL vulnerabilities found)"

            emailext(
                subject: "üö® OWASP Dependency Check FAILED | Pipeline Stopped",
                body: """
OWASP Dependency-Check FAILED.

‚ùå HIGH / CRITICAL vulnerabilities detected
‚ùå Pipeline STOPPED
‚úî Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}

Review Jenkins ‚Üí Dependency-Check for:
- CVE list
- Affected dependencies
- CVSS scores
- License issues
""",
                to: 'security-ao@company.com'
            )
        }
    } */
}




stage('Build & Push Docker Images') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login $LMS_REGISTRY_URL \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image"
          docker build --no-cache -t ${apiImage} ./api

          echo "üì§ Pushing API image"
          docker push ${apiImage}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image"
          docker build --no-cache -t ${webappImage} ./webapp

          echo "üì§ Pushing WebApp image"
          docker push ${webappImage}
        """
      }
    }
  }
}


   stage('Trivy Docker Image Scan') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      sh """
        echo "üîé Scanning API image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${apiImage} | tee trivy-api-scan.txt

        echo "üîé Scanning WebApp image with Trivy..."
        trivy image --exit-code 1 --severity HIGH,CRITICAL \
          --format table ${webappImage} | tee trivy-webapp-scan.txt
      """
    }
  }
}


/*
stage('Build & Push Docker Images') {
  steps {
    script {

      // Short local image names (ONLY these remain on Jenkins)
      def apiLocal    = "lms-api:${env.BUILD_NUMBER}"
      def webLocal    = "lms-webapp:${env.BUILD_NUMBER}"

      // Nexus image names (temporary on Jenkins)
      def apiRemote   = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webRemote   = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh """
          echo "üõ†Ô∏è Building API image (short name only)"
          docker build --no-cache -t ${apiLocal} ./api

          echo "üè∑Ô∏è Tagging API image for Nexus"
          docker tag ${apiLocal} ${apiRemote}
          

          echo "üì§ Pushing API image to Nexus"
          docker push ${apiLocal} ${apiRemote}
        """

        sh """
          echo "üõ†Ô∏è Building WebApp image (short name only)"
          docker build --no-cache -t ${webLocal} ./webapp

          echo "üè∑Ô∏è Tagging WebApp image for Nexus"
          docker tag ${webLocal} ${apiRemote}

          echo "üì§ Pushing WebApp image to Nexus"
          docker push ${webLocal} ${webRemote}

         
        """
      }
    }
  }
}
*/

/*
stage('üöÄ Deploy LMS via Docker Compose') {
  steps {
    script {
      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        //passwordVariable: 'NEXUS_PASSWORD'
      )]) {

dir('/opt/jenkins/lms') {
        sh '''
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

        sh '''
          export BUILD_NUMBER=${BUILD_NUMBER}
          docker compose down
          docker compose pull
          docker compose up -d
        '''
      }
    }
}

  }
}  

*/



stage('üöÄ Deploy LMS via Docker Run') {
  steps {
    script {
      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
            -u "$NEXUS_USERNAME" --password-stdin

          docker network create lms-net || true

          docker rm -f lms-webapp lms-api lms-postgres || true

          docker run -d \
            --name lms-postgres \
            --network lms-net \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=postgres@123 \
            -e POSTGRES_DB=mydb \
            -v lms-db-data:/var/lib/postgresql/data \
            postgres:15

          docker run -d \
            --name lms-api \
            --network lms-net \
            -p 8081:8081 \
            -e MODE=prod \
            -e PORT=8080 \
            -e DATABASE_URL=postgresql://postgres:strongpassword@lms-postgres:5432/mydb \
            ${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}

          docker run -d \
            --name lms-webapp \
            --network lms-net \
            -p 3000:80 \
            -e MODE=prod \
            -e API_URL=http://lms-api:8081 \
            ${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}
        '''
      }
    }
  }
}


    }
}   


this is my existing pipeline getting these below 

+ echo ****

+ docker login **** -u admin --password-stdin

Login Succeeded

export BUILD_NUMBER=${BUILD_NUMBER} docker compose down docker compose pull docker compose up -d
0.26s

+ export BUILD_NUMBER=52

+ docker compose down

no configuration file provided: not found

script returned exit code 1
