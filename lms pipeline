LMS Pipeline


pipeline {
    agent any
tools {
        jdk 'jdk_21'
        nodejs 'node_22'
        
    }
    
     environment {
       SONAR_TOKEN     = credentials('lms_sonartoken')
       SCANNER_HOME    = tool 'sonar_scanner'
        LMS_REGISTRY_URL = credentials('LMS_NEXUS_REGISTRY_URL')
        LMS_DOCKER_REPO  = credentials('LMS_NEXUS_DOCKER_REPO')
        LMS_PROJECT_NAME = credentials('LMS_NEXUS_PROJECT')
        TRIVY_DISABLE_UNICODE = "true"
    }
    
    stages {
        stage('üì• Checkout Code') {
        steps {
            git branch: 'dev',
                credentialsId: 'github-token',
                url: 'https://github.com/mahesharimalla/lms.git'
        }
    }
    
stage('Gate-0A: Gitleaks ‚Äì Secret Detection') {
  steps {
    sh '''
      set -e
      echo "üîç Gitleaks: scanning for secrets"

      mkdir -p security-reports/gitleaks

      gitleaks detect \
        --source . \
        --no-git \
        --config .gitleaks.toml \
        --redact \
        --report-format json \
        --report-path security-reports/gitleaks/report.json
    '''
  }
}



stage('Gate-0B: TruffleHog ‚Äì Verified Secrets') {
  steps {
    script {
      sh '''
        echo "üîç TruffleHog: scanning for verified secrets"

        mkdir -p security-reports/trufflehog

        set +e
        trufflehog filesystem . \
          --only-verified \
          --no-update \
          --exclude-paths .git,node_modules,dist,build,target,coverage,security-reports \
          --json | tee security-reports/trufflehog/report.json

        set -e

        # Fail ONLY if verified secrets exist
        FINDINGS=$(jq 'length' security-reports/trufflehog/report.json 2>/dev/null || echo 0)

        if [ "$FINDINGS" -gt 0 ]; then
          echo "‚ùå Verified secrets detected by TruffleHog"
          exit 1
        fi

        echo "‚úÖ No verified secrets found"
      '''
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'security-reports/trufflehog/*', fingerprint: true
    }
    failure {
      error('‚ùå Gate-0B FAILED ‚Äì Verified secrets detected')
    }
  }
}




stage('Gate-0C: Semgrep ‚Äì Org Secret Policy') {
  steps {
    sh '''
      set -e
      echo "üîç Semgrep: enforcing org policy"

      mkdir -p security-reports/semgrep

      docker run --rm \
        -v "$PWD:/src" \
        returntocorp/semgrep \
        semgrep scan \
          --config /src/semgrep/org-policy.yml \
          --json \
          --output /src/security-reports/semgrep/report.json
    '''
  }
}
    
    
        stage('Compile Applications') {
    parallel {
        stage('Compile Backend') {
            steps {
                dir('api') {
                    sh '''
                      npm install
                      npx prisma generate
                      npm run lint
                      npm run build
                    '''
                }
            }
        }

        stage('Compile Frontend') {
            steps {
                dir('webapp') {
                    sh '''
                      npm install
                      npm run build
                    '''
                }
            }
        }
    }
}


 



stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar_server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner \\
                           -Dsonar.projectName=lms \\
                           -Dsonar.sources=. \\
                           -Dsonar.projectKey=lms '''
                }
            }
        }



stage('Gate-1: SAST (SonarQube)') {
    steps {
        script {
            try {
                timeout(time: 2, unit: 'MINUTES') {
                    def qg = waitForQualityGate()

                    echo "Gate-1 Status: ${qg.status}"

                    // ‚úÖ If Quality Gate passed ‚Üí continue
                    if (qg.status == 'OK') {
                        echo "Quality Gate passed. No approval required."
                    }
                    // ‚ùå If failed / warn / pending ‚Üí approval required
                    else {
                        def approval = input(
                            message: """
Gate-1 (SAST) did NOT pass ‚ùå

SonarQube Status: ${qg.status}

Component AO approval is required to continue.
""",
                            ok: 'Approve & Continue',
                            parameters: [
                                string(
                                    name: 'JUSTIFICATION',
                                    defaultValue: '',
                                    description: 'Why is this risk acceptable? (Ticket / Reason)'
                                )
                            ]
                        )

                        echo "Gate-1 approved by Component AO. Justification: ${approval}"
                    }
                }
            }
            // ‚è≥ Handles SonarQube stuck / timeout case
            catch (err) {
                def approval = input(
                    message: """
Gate-1 (SAST) TIMEOUT ‚è≥

SonarQube did not return a Quality Gate result in time.

Component AO approval is required to continue.
""",
                    ok: 'Approve & Continue',
                    parameters: [
                        string(
                            name: 'JUSTIFICATION',
                            defaultValue: '',
                            description: 'Why is this risk acceptable? (Ticket / Reason)'
                        )
                    ]
                )

                echo "Gate-1 approved after timeout. Justification: ${approval}"
            }
        }
    }
}




stage('üõ°Ô∏è Gate-2: OWASP Dependency Check') {
    steps {
        echo "üîç Running OWASP Dependency-Check with Quality Gates..."

        dependencyCheck(
            odcInstallation: 'DP_Check',
            additionalArguments: """
                --project LMS-Application
                --scan .
                --format XML
                --failOnCVSS 7
            """
        )

        dependencyCheckPublisher(
            pattern: '**/dependency-check-report.xml'
        )
    }

    post {
        success {
            echo "‚úÖ Dependency-Check PASSED (No HIGH / CRITICAL vulnerabilities)"
        }

        failure {
            echo "‚ùå Dependency-Check FAILED (HIGH / CRITICAL vulnerabilities found)"

            emailext(
                subject: "üö® OWASP Dependency Check FAILED | Pipeline Stopped",
                body: """
OWASP Dependency-Check FAILED.

‚ùå HIGH / CRITICAL vulnerabilities detected
‚ùå Pipeline STOPPED

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
""",
                to: 'security-ao@company.com'
            )
        }
    }
}




stage('Build & Push Docker Images') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      withCredentials([usernamePassword(
        credentialsId: 'nexus_cred',
        usernameVariable: 'NEXUS_USERNAME',
        passwordVariable: 'NEXUS_PASSWORD'
      )]) {

        sh '''
          echo "‚öôÔ∏è Logging in to Nexus Docker Registry..."
          echo "$NEXUS_PASSWORD" | docker login $LMS_REGISTRY_URL \
            -u "$NEXUS_USERNAME" --password-stdin
        '''

//echo "üßπ Removing old API image (if exists)..."
//docker rmi -f ${apiImage} 2>/dev/null || true

//echo "üßπ Removing old WebApp image (if exists)..."
//docker rmi -f ${webappImage} 2>/dev/null || true

        sh """
echo "üßπ Cleaning old lms-api images..."
docker images "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api" \
  --format "{{.Repository}}:{{.Tag}}" \
  | grep -v "${BUILD_NUMBER}" \
  | xargs -r docker rmi -f


echo "üõ†Ô∏è Building API image"
docker build --no-cache -t ${apiImage} ./api

echo "üì§ Pushing API image"
docker push ${apiImage}
"""

        sh """
echo "üßπ Cleaning old lms-api images..."
docker images "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp" \
  --format "{{.Repository}}:{{.Tag}}" \
  | grep -v "${BUILD_NUMBER}" \
  | xargs -r docker rmi -f


echo "üõ†Ô∏è Building WebApp image"
docker build --no-cache -t ${webappImage} ./webapp

echo "üì§ Pushing WebApp image"
docker push ${webappImage}
"""

      }
    }
  }
}


   


//should add --exit-code 1 after --severity tag
stage('Gate-3: Trivy Docker Image Scan') {
  steps {
    script {
      def apiImage    = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-api:${env.BUILD_NUMBER}"
      def webappImage = "${LMS_REGISTRY_URL}/repository/${LMS_DOCKER_REPO}/lms-webapp:${env.BUILD_NUMBER}"

      sh """
        echo "üîé Scanning API image with Trivy..."
        trivy image \
          --severity HIGH,CRITICAL \
          --format json \
          --output trivy-api-report.json \
          --quiet \
          ${apiImage}

        echo "üîé Scanning WebApp image with Trivy..."
        trivy image \
          --severity HIGH,CRITICAL \
          --format json \
          --output trivy-webapp-report.json \
          --quiet \
          ${webappImage}
      """
    }
  }
  post {
    always {
      archiveArtifacts artifacts: 'trivy-*-report.json', fingerprint: true
    }
  }
}




stage('üöÄ Deploy LMS via Docker Run (Secure)') {
  steps {
    script {
      withCredentials([
        usernamePassword(
          credentialsId: 'nexus_cred',
          usernameVariable: 'NEXUS_USERNAME',
          passwordVariable: 'NEXUS_PASSWORD'
        ),
        //string(credentialsId: 'LMS_POSTGRES_USER', variable: 'LMS_POSTGRES_USER'),
        //string(credentialsId: 'LMS_POSTGRES_PASSWORD', variable: 'LMS_POSTGRES_PASSWORD'),
        //string(credentialsId: 'LMS_POSTGRES_DB', variable: 'LMS_POSTGRES_DB'),
        //string(credentialsId: 'DATABASE_URL', variable: 'DATABASE_URL')
      ]) {

        sh(
          shell: '/bin/bash',
          script: '''
            set -e
            set +x

            echo "üîê Logging in to Nexus"
            echo "$NEXUS_PASSWORD" | docker login "$LMS_REGISTRY_URL" \
              -u "$NEXUS_USERNAME" --password-stdin

            echo "üåê Creating Docker network"
            docker network create lms-net || true

            echo "üßπ Cleaning old containers"
            docker rm -f lms-webapp lms-api lms-postgres 2>/dev/null || true

            echo "üêò Starting PostgreSQL"
            docker run -d \
              --name lms-postgres \
              --network lms-net \
              --restart unless-stopped \
              -e POSTGRES_USER="postgres" \
              -e POSTGRES_PASSWORD="postgres123" \
              -e POSTGRES_DB="mydb" \
              -v lms-db-data:/var/lib/postgresql/data \
              postgres:15

echo "‚è≥ Waiting for PostgreSQL to be ready..."
for i in {1..20}; do
  if docker exec lms-postgres pg_isready -U postgres > /dev/null 2>&1; then
    echo "‚úÖ PostgreSQL is ready"
    break
  fi
  sleep 3
done

   echo "üóÑÔ∏è Running Prisma migrations (one-time)..."
docker run --rm \
  --network lms-net \
  -e DATABASE_URL="postgresql://postgres:postgres123@lms-postgres:5432/mydb" \
  "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-api:$BUILD_NUMBER" \
  npx prisma migrate deploy  
  
  
            echo "üöÄ Starting LMS API"
            docker run -d \
              --name lms-api \
              --network lms-net \
              --restart unless-stopped \
              -p 8081:8081 \
              -e MODE=production \
              -e PORT=8081 \
              -e DATABASE_URL="postgresql://postgres:postgres123@lms-postgres:5432/mydb" \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-api:$BUILD_NUMBER"

    echo "‚è≥ Waiting for API to be healthy..."
for i in {1..20}; do
  if curl -fs http://127.0.0.1:8081/health; then
    echo "‚úÖ API is healthy"
    break
  fi
  sleep 3
done

            echo "üåê Starting LMS WebApp"
            docker run -d \
              --name lms-webapp \
              --network lms-net \
              --restart unless-stopped \
              -p 3001:80 \
              -e VITE_API_URL=http://192.162.11.18:8081/api \
              "$LMS_REGISTRY_URL/repository/$LMS_DOCKER_REPO/lms-webapp:$BUILD_NUMBER"
          '''
        )
      }
    }
  }
}




stage('Gate-4: DAST - OWASP ZAP (Automation Framework)') {
    steps {
        sh '''#!/bin/bash
          set -euo pipefail

          echo "üßπ Cleaning old ZAP reports..."
          rm -rf zap-report/*
          mkdir -p zap-report
          chmod 777 zap-report

          echo "üîç Running OWASP ZAP Automation Framework..."

    docker run --rm \
  --network host \
  -v "$PWD/zap-report:/zap/wrk" \
  -v "$PWD/zap/zap-automation.yaml:/zap/zap-automation.yaml" \
  zaproxy/zap-weekly \
  zap.sh -cmd -port 8090 -autorun /zap/zap-automation.yaml

        '''
    }
    post {
        always {
            echo "üìä Publishing OWASP ZAP report..."
            publishHTML(target: [
                reportDir: 'zap-report',
                reportFiles: 'zap-report.html',
                reportName: 'OWASP ZAP DAST Report',
                keepAll: true,
                alwaysLinkToLastBuild: true,
                allowMissing: true
            ])
        }
        failure {
            echo '‚ùå Gate-4 FAILED ‚Äì High/Critical DAST vulnerabilities detected'
        }
        success {
            echo '‚úÖ Gate-4 PASSED ‚Äì DAST security gate cleared'
        }
    }
}

}
}
